(defpackage :calculator
  (:use :common-lisp))
(in-package :calculator)

(defun combine-expr (oprtr oprnd-1 lst)
  (list
   (list oprtr oprnd-1 (first lst))
   (rest lst)))
(defun enclose-expression (expr)
  "'(5 + 3 - 2) => '(- (+ 5 3) 2)"
  (check-type expr list)
  (cond ((< (length expr) 3) expr)
        ((if
          (and (> (length expr) 4)
               (string= (symbol-name (second expr)) "^")
               (not (string= (symbol-name (fourth expr)) "^")))
          (enclose-expression (cons (first (combine-expr (second expr) (first expr) (list (third expr))))
                                    (rest (rest (rest expr)))))
          '()))
        (t (enclose-expression (cons (first (combine-expr (second expr) (first expr) (list (third expr))))
                                     (rest (rest (rest expr))))))))
(defun remaining (l1 l2)
  "return the remaining elements from longer list:- (5) (5 1 2 3 4) -> (1 2 3 4)"
  (check-type l1 list)
  (check-type l2 list)
  (cond ((null l1) l2)
        (t (remaining (rest l1) (rest l2)))))
(defun till-plus-minus (expr)
  "'(5 - 4 + 3) => (5), '(5 * 3 / 2 + 7 - 8) => (5 * 3 / 2)"
  (cond ((null expr) '())
        ((and (symbolp (first expr))
              (or (string= (symbol-name (first expr)) "+")
                  (string= (symbol-name (first expr)) "-"))) '())
        (t (cons (first expr) (till-plus-minus (rest expr))))))
(defun till-mul-div (expr)
  (cond ((null expr) '())
        ((and (symbolp (first expr))
              (or (string= (symbol-name (first expr)) "*")
                  (string= (symbol-name (first expr)) "/"))) '())
        (t (cons (first expr) (till-mul-div (rest expr))))))
(defun enclose-term (expr)
  "'(5 - 4 + 3) => (5 - 4 + 3), '(5 * 3 / 2 + 7 - 8) => ((/ (* 5 3) 2) + 7 - 8)"
  (let ((rslt (till-plus-minus expr)))
    (cons (first (enclose-expression rslt)) (remaining rslt expr))))
(defun enclose-factor (expr)
  (let* ((tmv (till-mul-div expr))
         (rem (cons tmv (remaining tmv expr)))
         (a (cl:nreverse (rest (cl:nreverse (till-mul-div expr)))))
         (b (list (first (combine-expr (second rem) (first (last (first rem))) (rest (rest rem)))))))
    (princ tmv)
    (princ rem)
    (princ a)
    (princ b)
    (append a b)))
(defun prefix (expr)
  (if (null expr) '()
      (enclose-expression expr)))
