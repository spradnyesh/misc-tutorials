(defpackage :bstree
  (:use :cl))
(in-package bstree)

(shadow 'cl:tree-equal)
(defun tree-equal (t1 t2)
  (cond ((atom t1) (atom-equal t1 t2))
        ((atom t2) nil)
        ((tree-equal (first t1) (first t2))
         (tree-equal (rest t1) (rest t2)))
        (t nil)))
(deftype bstree ()
  "A BSTree is a Binary Search Tree"
  '(satisfies bstreep))
(defun bstreep (tree)
  "A bstree is either an element or a three-member list
   the first of which is an element"
  (or (typep tree 'util:element)
      (and (listp tree)
           (= (length tree) 3)
           (typep (first tree) 'util:element))))
(defun bstree-insert (ele tree)
  (check-type ele util:element)
  (check-type tree bstree)
  (cond ((null tree) ele)
        ((eql ele (bstree-root tree)) tree)
        ((string< ele (bstree-root tree))
         (list (bstree-root tree)
               (bstree-insert ele (bstree-left tree))
               (bstree-right tree)))
        (t (list (bstree-root tree)
                 (bstree-left tree)
                 (bstree-insert ele (bstree-right tree))))))
(defun bstree-root (tree)
  (check-type tree bstree)
  (if (atom tree) tree
      (first tree)))
(defun bstree-left (tree)
  (check-type tree bstree)
  (if (atom tree) '()
      (second tree)))
(defun bstree-right (tree)
  (check-type tree bstree)
  (if (atom tree) '()
      (third tree)))
(defun depth (tree)
  (if (atom tree) 0
      (1+ (max-depth-members tree))))
(defun max-depth-members (tree)
  (check-type tree list)
  (if (null tree) 0
      (max (depth (first tree))
           (max-depth-members (rest tree)))))
(defun build-from-list (lst)
  "'(a binary search tree is a useful tree))
   (TREE (A NIL (IS BINARY SEARCH)) USEFUL)"
  (check-type lst list)
  (cond ((= (length lst) 1) (first lst))
        (t (bstree-insert (first lst) (build-from-list (rest lst))))))

