(defpackage :ch19
  (:use :cl))
(in-package :ch19)

(defun my-nth (n lst)
  (check-type n integer)
  (check-type lst list)
  (if (= n 0)
      (first lst)
      (my-nth (1- n) (rest lst))))
(defun lazy-next (lst)
  (check-type lst list)
  (if (eql (second lst) :promise)
      (lazy-next (second (first (last lst))))
      (list (first lst) :promise 'lazy-next `',(rest lst))))
(defun lazy-nth (n lst)
  (check-type n integer)
  (check-type lst list)
  (cond ((zerop n) (first (lazy-next lst)))
        ((null lst) '())
        (t (lazy-nth (1- n) (lazy-next lst)))))
(defun correct-lazy-nth (n lst)
  (check-type n (and integer (satisfies plusp)))
  (check-type lst list)
  (if (= 1 n) (first lst)
      (correct-lazy-nth (1- n) (apply (third lst) (fourth lst)))))
(defun fibonacci-list (n m)
  (check-type n integer)
  (check-type m integer)
  (list n :promise 'fibonacci-list (list m (+ n m))))
(defun relatively-prime (n integers)
  "return 'nil if n % i = 0 for any i in integers, t otherwise"
  (cond ((null integers) t)
        ((zerop (mod n (first integers))) nil)
        (t (relatively-prime n (rest integers)))))
(defun primes-from (n others)
  "If (relatively-prime n others), then n is the first prime on the desired list; otherwise the list is generated by (primes-from (1+ n) others)"
  (if (relatively-prime n others)
      (list n :promise 'primes-from (list (1+ n) (append others (list n))))
      (primes-from (1+ n) others)))
;(defun till-n (n); did not get used ;)
;  (if (zerop n) '()
;      (append (till-n (1- n)) (list n))))
(defun first-n-of-list-with-index (n fn args)
  (if (zerop n) '()
      (append (first-n-of-list-with-index (1- n) fn args)
            (list (list n (correct-lazy-nth n (apply fn args)))))))
(defun first-n-of-list-without-index (n fn args)
  (if (zerop n) '()
      (append (first-n-of-list-without-index (1- n) fn args)
            (list (correct-lazy-nth n (apply fn args))))))
